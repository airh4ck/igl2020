<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-03-03 Wed 19:37 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>model.lean</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Vaibhav Karve" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">model.lean
<br />
<span class="subtitle">Model theory formalized in Lean  <br> <a href="type_theory.html">Link to file: type theory</a></span>
</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org87a8553">1. <span class="todo TODO">TODO</span> Arity \(n\) functions and their API</a></li>
<li><a href="#org218dd4f">2. Languages</a>
<ul>
<li><a href="#org23784a5">2.1. Definition and implementation</a></li>
<li><a href="#orge0af99f">2.2. Constants</a></li>
<li><a href="#org1e053dc">2.3. DLO language</a></li>
<li><a href="#org11982ea">2.4. <code>lang</code> is an inhabited type</a></li>
</ul>
</li>
<li><a href="#org123487d">3. Structures</a>
<ul>
<li><a href="#orgc13cdce">3.1. <code>struc</code> is inhabited</a></li>
</ul>
</li>
<li><a href="#org0d040e9">4. Embedding between structures</a>
<ul>
<li><a href="#orgd7aac45">4.1. Embedding</a></li>
<li><a href="#orgf2d3054">4.2. Embeddings are inhabited</a></li>
<li><a href="#org605013d">4.3. Isomorphism</a></li>
<li><a href="#orge965129">4.4. Isomorphisms are inhabited</a></li>
<li><a href="#org66ed004">4.5. Cardinality of structure</a></li>
</ul>
</li>
<li><a href="#orgf494227">5. Terms</a>
<ul>
<li><a href="#org5fce107">5.1. Definition of terms</a></li>
<li><a href="#orgb371b45">5.2. <span class="todo TODO">TODO</span> Implementation of terms</a></li>
<li><a href="#org1e9dce5">5.3. <span class="todo TODO">TODO</span> Depth of a term</a></li>
<li><a href="#org189adb4">5.4. <span class="todo TODO">TODO</span> Terms are inhabited</a></li>
<li><a href="#org67bfae9">5.5. <span class="todo TODO">TODO</span> Variables in a term</a></li>
<li><a href="#orgb430460">5.6. <span class="todo TODO">TODO</span> Number of variables in a term</a></li>
<li><a href="#org3a73628">5.7. Term interpretation</a>
<ul>
<li><a href="#org19dc256">5.7.1. Variable interpretation using variable assignment</a></li>
<li><a href="#org195288b">5.7.2. Full implementation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org84727d4">6. <span class="todo TODO">TODO</span> Term substitution</a></li>
<li><a href="#org5959770">7. Formulas and Sentences</a>
<ul>
<li><a href="#org6d9c6c3">7.1. Definition of a formula</a></li>
<li><a href="#orge39f572">7.2. Implementation of a formula</a></li>
<li><a href="#orgf79ca72">7.3. Notation for logical operators</a></li>
<li><a href="#org0511110">7.4. <span class="todo TODO">TODO</span> Helper functions</a></li>
<li><a href="#orga39a46c">7.5. Free and bound variables</a></li>
<li><a href="#orgede1f63">7.6. Definition of a sentence</a></li>
</ul>
</li>
<li><a href="#orgb25f998">8. Satisfiability and models</a>
<ul>
<li><a href="#orgbd425d7">8.1. <span class="todo TODO">TODO</span> Expanding a language and structure</a></li>
<li><a href="#orga69fad5">8.2. Structure models/satisfies a formula</a>
<ul>
<li><a href="#org3c25bed">8.2.1. Implementation detail for quantifiers</a></li>
</ul>
</li>
<li><a href="#orgd45c798">8.3. <span class="todo TODO">TODO</span> Lemmas about satisfaction of formulae</a></li>
<li><a href="#orgc88967d">8.4. <span class="todo TODO">TODO</span> Model</a></li>
</ul>
</li>
<li><a href="#orgb82c6fc">9. <span class="todo TODO">TODO</span> Bibliography</a></li>
</ul>
</div>
</div>


<div id="outline-container-org87a8553" class="outline-2">
<h2 id="org87a8553"><span class="section-number-2">1</span> <span class="todo TODO">TODO</span> Arity \(n\) functions and their API</h2>
</div>
<div id="outline-container-org218dd4f" class="outline-2">
<h2 id="org218dd4f"><span class="section-number-2">2</span> Languages</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org23784a5" class="outline-3">
<h3 id="org23784a5"><span class="section-number-3">2.1</span> Definition and implementation</h3>
<div class="outline-text-3" id="text-2-1">
<p>
A <i>language</i> is given by specifying "functions'', "relations" and "constants"
along with the arity of each function and each relation. Note that languages are
purely syntactic &#x2013; they have no sematics (i.e. meaning assigned to them).
</p>

<p>
The words "functions", "relations", and "constant" are written in quotes here
to emphasize that these are just the names we give to these pieces of data. We
could equivalently have called them F, R, and C. They do not yet behave like
actual functions, relations and constants because we have not added any semantic
information to them. For now, they are merely symbols in our language.
</p>

<p>
In lean, we use <b>structure</b> to bundle data (think of it like classes in Python).
So, we bundle functions and relations in a structure and call it a language.
</p>

<p>
Implementation details &#x2013;
</p>
<ol class="org-ol">
<li>Constants are included in the mathematical definition of languages but not in
out immediate implementation of <code>lang</code> (see subsection that follows for an
explanation).</li>
<li>The definition says that every function and relation is supposed to have an
arity.  In our implementation, we invert this and instead stipulate that
every arity (i.e. every natural number) has a type assiciated with it. What
type is that? The type corresponding to \((n : ℕ)\) is the type of all
\(n\)-arity functions in our language.</li>
<li>Thus, \(F : ℕ → Type\) is the function that returns a type for each natural
number. Similarly for \(R\).</li>
<li>We also note that since each <code>lang</code> contains an <code>F</code> and an <code>R</code> that
themselves return types, the type of <code>lang</code> itself is <code>Type 1</code>, which one
universe higher than <code>Type</code>.  In other words, <code>Type</code> is too small to contain
<code>lang</code>, so languages must live in a higher universe.  This is a small detail
that does not affect the rest of treatment of model theory in any way.</li>
</ol>
</div>
</div>

<div id="outline-container-orge0af99f" class="outline-3">
<h3 id="orge0af99f"><span class="section-number-3">2.2</span> Constants</h3>
<div class="outline-text-3" id="text-2-2">
<p>
We define the constants in a language to simply be the \(0\)-arity functions
i.e. <code>L.F 0</code>. (Think of constants as simply a convenient way to refer to
\(0\)-arity functions). They do not add any new information to the <code>lang</code>
already defined above.
</p>
<ol class="org-ol">
<li>This uses the fact that natural numbers in Lean begin at \(0\), not \(1\).</li>
<li>This is the reason why we did not need to include constants in out
implementation of languages.</li>
</ol>
</div>
</div>

<div id="outline-container-org1e053dc" class="outline-3">
<h3 id="org1e053dc"><span class="section-number-3">2.3</span> DLO language</h3>
<div class="outline-text-3" id="text-2-3">
<p>
The language that is of primary interest to us is the language of dense linear
ordering.
</p>

<p>
A <i>dense linear ordering (without endpoints)</i> (DLO) is a language containing a
single binary relation symbol \((\le)\) satisfying some axioms. The exact axioms
are not important at the moment since axioms are semantic statements, while we
are interested only in syntactic statements right now.
</p>

<p>
Thus, a DLO's <code>lang</code> is a language with no constant, no functions and only one
binary relation. (Refer to the type theory primer for the meaning of <code>empty</code>,
<code>unit</code> etc.).
</p>
</div>
</div>

<div id="outline-container-org11982ea" class="outline-3">
<h3 id="org11982ea"><span class="section-number-3">2.4</span> <code>lang</code> is an inhabited type</h3>
<div class="outline-text-3" id="text-2-4">
<p>
We can now declare that <code>lang</code> is an inhabited (read: nonempty) type since we
know that <code>DLO_lang</code> is a <code>lang</code>. This declaration is made using Lean's
<code>instance</code> keyword. This declaration automatically makes the nonemptiness of
<code>lang</code> available as a fact to Lean's typeclass resolver if needed.
</p>
</div>
</div>
</div>

<div id="outline-container-org123487d" class="outline-2">
<h2 id="org123487d"><span class="section-number-2">3</span> Structures</h2>
<div class="outline-text-2" id="text-3">
<p>
Given a language \(L\), an <i>\(L\)-structure</i> is a bundle of the following 4
pieces of data.
</p>

<ol class="org-ol">
<li>A set called the universe or domain. We implement this as a type rather than
a set because Lean is based on type theory.</li>

<li>For every symbolic function of arity \(n\) in \(L\), we must have a
corresponding real function of arity \(n\) acting on the universe of
\(M\). To implement this, we map every <code>(f : L.F n)</code> to <code>Func univ v</code>. Since
we need a name for this map, we name it <code>F</code>. Thanks to namespaces in lean,
the full name for this map is <code>struc.F</code> or <code>M.F</code> where \(M\) is a <code>struc</code>,
and hence there is no chance of mixing this up with <code>lang.F</code> or <code>L.F</code>. We
will denote the interpretation of the symbolic function \(f\) under the
structure \(M\) as <code>f^M</code>.</li>

<li>For every symbolic relation of arity \(n\) in \(L\), we must have a
corresponding real relation of arity \(n\) on the universe of \(M\). At this
point, it is useful to recall that the proper definition of a relation is as
a subset if the domain set. What do I mean?  While we like to think of a
binary relation for example as a relation "between" elements of our set, it
is in fact better to view it as a subset of the Cartesian product of the
domain with itself. Pairs belonging to this subset are related while pairs
not belonging are not.  Similarly, \(3\)-ary relations are subsets of
<code>univ³</code>, and so on. Thus we map each element <code>(r : L.R n)</code> to <code>set (vector
   univ n)</code>, i.e. we map to a set of length \(n\) vectors of <code>univ</code>. We will
denote the interpretation of the symbolic relation \(r\) under the structure
\(M\) as <code>r̂M</code>.</li>

<li>For every symbolic constant in \(L\), we must have a corresponding constant
in the universe/domain. Since <code>L.C</code> is implemented outside of \(L\), we
similarly implement <code>M.C</code> outside of \(M\). It is implemented as a
restriction of <code>M.F</code> to \(0\)-arity functions.</li>
</ol>
</div>

<div id="outline-container-orgc13cdce" class="outline-3">
<h3 id="orgc13cdce"><span class="section-number-3">3.1</span> <code>struc</code> is inhabited</h3>
<div class="outline-text-3" id="text-3-1">
<p>
We can now declare that <code>struc L</code> is an inhabited (read: nonempty) type for
every language \(L\). In other words, every language has at least one structure
defined on it.
</p>

<p>
The default value for <code>struc L</code> has &#x2013;
</p>
<ul class="org-ul">
<li>a universe/domain with only one element</li>
<li>corresponding to every symbolic function \(f\) in \(L\), <code>f^M</code> is the
function that maps everything to the singleton element.</li>
<li>corresponding to every symbolic relation \(r\) in \(L\), <code>r̂M</code> is the empty
relation.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org0d040e9" class="outline-2">
<h2 id="org0d040e9"><span class="section-number-2">4</span> Embedding between structures</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgd7aac45" class="outline-3">
<h3 id="orgd7aac45"><span class="section-number-3">4.1</span> Embedding</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Given two structures on the same language, an <i>embedding</i> between them is a map
that is injective on the universe/domain and preserves the interpretation of all
the elements of the language.
</p>

<p>
For ease of writing, we first introduce some notation. Given a function of arity
\(n\) <code>(f : Func α n)</code>, and an \(n\)-vector \(v\), we will write \(f\otimes v\)
to mean that the function \(f\) is to be applied to the \(n\) elements of \(v\)
to yield a value in <code>α</code>.
</p>

<p>
To start, we let \(L\) denote the language, and \(M\) and \(N\) denote the
structures on \(L\). Then the map <code>η : M.univ → N.univ</code> is an embedding &#x2013;
</p>
<ol class="org-ol">
<li>If \(\eta\) it is injective</li>
<li>For every \(n\)-vector \(v\) and every \(n\)-arity symbolic function \(f\) in
\(L\), we have <code>η(f^M ⊗ v) = f^N ⊗ η(v)</code>, where \(\eta(v)\) denotes the
vector obtained by mapping every coordinate of \(v\) under \(\eta\).</li>
<li>For every \(n\)-vector \(v\) and every \(n\)-arity symbolic relation \(r\) in
\(L\), we have <code>v ∈ r̂M ↔ η(v) ∈ r̂N</code>, where \(\eta(v)\) again denotes the
vector obtained by mapping every coordinate of \(v\) under \(\eta\).</li>
</ol>
</div>
</div>

<div id="outline-container-orgf2d3054" class="outline-3">
<h3 id="orgf2d3054"><span class="section-number-3">4.2</span> Embeddings are inhabited</h3>
<div class="outline-text-3" id="text-4-2">
<p>
We argue that every structure has an embedding to itself via the indentity map.
</p>

<p>
For this embedding, the \(\eta\) map is the identity map on the universe of
\(M\). This map is clearly injective and it trivially preserves the interpretation of every function, relation, and constant.
</p>

<p>
Thus, <code>embedding M M</code> is an inhabited type (read: nonempty), for every structure
\(M\).
</p>
</div>
</div>

<div id="outline-container-org605013d" class="outline-3">
<h3 id="org605013d"><span class="section-number-3">4.3</span> Isomorphism</h3>
<div class="outline-text-3" id="text-4-3">
<p>
An <i>isomorphism</i> is a bijective embedding between two \(L\)-structures. To implement this, we define an isomorphism to be a structure in Lean that extends embeddings. This means &#x2013;
</p>
<ol class="org-ol">
<li>there is a natural map <code>to_embedding : isomorphism M N → embedding M N</code>.</li>
<li>an isomorphism is the data contained in an embedding bundled with a proof of
the bijectivity of the \(\eta\) map.</li>
</ol>
</div>
</div>

<div id="outline-container-orge965129" class="outline-3">
<h3 id="orge965129"><span class="section-number-3">4.4</span> Isomorphisms are inhabited</h3>
<div class="outline-text-3" id="text-4-4">
<p>
We argue that every structure has an isomorphism to itself via the identity map.
</p>

<p>
Thus, <code>isomorphism M M</code> is an inhabited type (read: nonempty), for every
structure \(M\).
</p>
</div>
</div>

<div id="outline-container-org66ed004" class="outline-3">
<h3 id="org66ed004"><span class="section-number-3">4.5</span> Cardinality of structure</h3>
<div class="outline-text-3" id="text-4-5">
<p>
The <i>cardinality</i> of a structure is defined to be the cardinality of its
domain. In Lean, the cardinals are their own separate type which is why we
need to "make" the cardinal from the universe of \(M\).
</p>

<p>
We can then claim that if \(\eta : M \rightarrow N\) is an embedding of
\(M\) in \(N\), then the cardinality of \(M\) must be at most the
cardinality of \(N\). In other words, only smaller structures can be
embedded into larger structures.
</p>

<p>
The proof hinges on the injectivity of \(\eta\) and follows from the fact
<code>cardinal.mk_le_of_injective</code> (which is already proved in mathlib).
</p>
</div>
</div>
</div>

<div id="outline-container-orgf494227" class="outline-2">
<h2 id="orgf494227"><span class="section-number-2">5</span> Terms</h2>
<div class="outline-text-2" id="text-5">
<p>
Throughout this section, let \(L\) be a language and let \(M\) be an
\(L\)-structure. Terms can be thought of as symbolic words in a language. We get
variables as words/terms for free (think of these as placeholder words). A
function applied to the correct number of arguments is also a word.
</p>
</div>

<div id="outline-container-org5fce107" class="outline-3">
<h3 id="org5fce107"><span class="section-number-3">5.1</span> Definition of terms</h3>
<div class="outline-text-3" id="text-5-1">
<p>
\(L\)-<i>Terms</i> are defined inductively as &#x2013;
</p>
<ul class="org-ul">
<li>constants of the language are all terms.</li>
<li>there is a countably infinite supply of indexed "variables", each of which are
also distinct terms.</li>
<li>an \(n\)-ary symbolic function of \(L\) applied to exactly \(n\) other terms
also yields a term.</li>
</ul>

<p>
This definition of terms has 2 distinct parts &#x2013;
</p>
<ol class="org-ol">
<li>There are atomic terms like constants and variables,</li>
<li>There are higher-order terms (i.e. terms made of other terms) like ones
formed by function application.</li>
</ol>
</div>
</div>

<div id="outline-container-orgb371b45" class="outline-3">
<h3 id="orgb371b45"><span class="section-number-3">5.2</span> <span class="todo TODO">TODO</span> Implementation of terms</h3>
<div class="outline-text-3" id="text-5-2">
<p>
The trickiest part of the definition of terms is checking that in higher-order
terms, an \(n\)-ary symbolic function is being applied to exactly \(n\)-many
terms. This check needs a proof of a fact like <code>(length = n)</code>. However, we
cannot incorporate this proof into the definition directly without running into
lean's issues of nested inductive types.
</p>

<p>
Our solution is to incorporate the notion of atomic/higher-order into our
implementation. To each term we associate a level. We start by stipulating that
atomic terms have level \(0\). A symbolic function applied to all its arguments
also has level \(0\), while a partially applied function has positive level.
</p>

<p>
We summarize the term to level translation below &#x2013;
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Term</th>
<th scope="col" class="org-left">Level</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">constant</td>
<td class="org-left">0</td>
</tr>

<tr>
<td class="org-left">variable</td>
<td class="org-left">0</td>
</tr>

<tr>
<td class="org-left">function</td>
<td class="org-left">level = arity of the function</td>
</tr>

<tr>
<td class="org-left">partially-applied function</td>
<td class="org-left">level = arity \(-\) # arguments already applied</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org1e9dce5" class="outline-3">
<h3 id="org1e9dce5"><span class="section-number-3">5.3</span> <span class="todo TODO">TODO</span> Depth of a term</h3>
</div>
<div id="outline-container-org189adb4" class="outline-3">
<h3 id="org189adb4"><span class="section-number-3">5.4</span> <span class="todo TODO">TODO</span> Terms are inhabited</h3>
</div>
<div id="outline-container-org67bfae9" class="outline-3">
<h3 id="org67bfae9"><span class="section-number-3">5.5</span> <span class="todo TODO">TODO</span> Variables in a term</h3>
</div>
<div id="outline-container-orgb430460" class="outline-3">
<h3 id="orgb430460"><span class="section-number-3">5.6</span> <span class="todo TODO">TODO</span> Number of variables in a term</h3>
</div>
<div id="outline-container-org3a73628" class="outline-3">
<h3 id="org3a73628"><span class="section-number-3">5.7</span> Term interpretation</h3>
<div class="outline-text-3" id="text-5-7">
<p>
Having defined terms as words in our language, we can then define an
interpretation for each word.
</p>

<p>
Recall that an \(L\)-structure can be seen as a way of interpreting
symbolic functions and relations as real functions and relations. This
interpretation carries over to terms as well once we define how variables
and function application are to be interpreted. A term of level \(n\) is
interpreted as an \(n\)-ary function on the universe of \(M\).
</p>

<p>
We denote the interpretation of term \(t\) under variable assignment \(va\) as
<code>t^^va</code>.
</p>
</div>

<div id="outline-container-org19dc256" class="outline-4">
<h4 id="org19dc256"><span class="section-number-4">5.7.1</span> Variable interpretation using variable assignment</h4>
<div class="outline-text-4" id="text-5-7-1">
<p>
For interpreting variables, we use a variable assignment map. This is a map
from variables (i.e. ℕ) to the domain of \(M\).
</p>
</div>
</div>

<div id="outline-container-org195288b" class="outline-4">
<h4 id="org195288b"><span class="section-number-4">5.7.2</span> Full implementation</h4>
<div class="outline-text-4" id="text-5-7-2">
<p>
For a given variable assignment map, term interpretation is defined
inductively on each variant of \(L\)-terms as follows:
</p>
<ol class="org-ol">
<li>A symbolic function \(f\) in \(L\) is interpreted as <code>f^M</code>.</li>
<li>In order to be compatible with the above interpretation, a constant in
\(L\) is interpreted via the map <code>M.C</code>.</li>
<li>A variable is interpreted via the variable assignment map.</li>
<li>Lastly, the application of a term \(t\) to a term of \(t_0\) is interpreted
as the interpretation of \(t\) partially applied to the interpretation of
\(t_0\) to yield a function of arity one less than the arity equal to the
arity of the term we started with.</li>
</ol>
</div>
</div>
</div>
</div>


<div id="outline-container-org84727d4" class="outline-2">
<h2 id="org84727d4"><span class="section-number-2">6</span> <span class="todo TODO">TODO</span> Term substitution</h2>
</div>
<div id="outline-container-org5959770" class="outline-2">
<h2 id="org5959770"><span class="section-number-2">7</span> Formulas and Sentences</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org6d9c6c3" class="outline-3">
<h3 id="org6d9c6c3"><span class="section-number-3">7.1</span> Definition of a formula</h3>
<div class="outline-text-3" id="text-7-1">
<p>
An \(L\)-<i>formula</i> on \(L\) is any one of the following "words" on the alphabet
\(L \cup \text{Var} \cup \{\top, \bot, =\}\), where Var denotes the set of all
variables &#x2013;
</p>
<ol class="org-ol">
<li>\(\top\) and \(\bot\) are formulas</li>
<li>\(t_1 = t_2\) is a formula, where \(t_1\) and \(t_2\) are \(L\)-terms.</li>
<li>\(r t_1 \ldots t_n\) is a formula, where \(r\) is a symbolic \(n\)-ary
relation in \(L\), and the \(t_i\)'s are \(L\)-terms.</li>
<li>If \(\phi, \psi\) are \(L\)-formulas, then so are \((\neg \phi)\),
\((\phi\wedge\psi)\), and \((\phi\vee\psi)\). <b>Note:</b> we have added
parenthesis here merely for ease of writing. They are not really a part of
the formula.</li>
<li>If \(x\) is a variable, and \(\phi\) is an \(L\)-formula, then \(\exists x
   \phi\) and \(\forall x \phi\) are \(L\)-formulas.</li>
</ol>
</div>
</div>

<div id="outline-container-orge39f572" class="outline-3">
<h3 id="orge39f572"><span class="section-number-3">7.2</span> Implementation of a formula</h3>
<div class="outline-text-3" id="text-7-2">
<p>
We implement this definition of an \(L\)-formula inductively by enumerating all
the cases. Since we do not have a separate type for variables in our
implementation, we simply denote variable \(x_i\) by the natural number \(i\).
</p>
</div>
</div>

<div id="outline-container-orgf79ca72" class="outline-3">
<h3 id="orgf79ca72"><span class="section-number-3">7.3</span> Notation for logical operators</h3>
<div class="outline-text-3" id="text-7-3">
<p>
We then introduce some notation for logical operators. We mark all symbols with
a "prime" in order to distinguish them from Lean's built-in symbols for
equality, and, or, not etc.
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Symbol</th>
<th scope="col" class="org-left">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>='</code></td>
<td class="org-left">formula.eq</td>
</tr>

<tr>
<td class="org-left"><code>¬'</code></td>
<td class="org-left">formula.neg</td>
</tr>

<tr>
<td class="org-left"><code>∧'</code></td>
<td class="org-left">formula.and</td>
</tr>

<tr>
<td class="org-left"><code>∨'</code></td>
<td class="org-left">formula.or</td>
</tr>

<tr>
<td class="org-left"><code>∃'</code></td>
<td class="org-left">formula.exi</td>
</tr>

<tr>
<td class="org-left"><code>∀'</code></td>
<td class="org-left">formula.all</td>
</tr>

<tr>
<td class="org-left"><code>⊤'</code></td>
<td class="org-left">formula.tt</td>
</tr>

<tr>
<td class="org-left"><code>⊥'</code></td>
<td class="org-left">formula.ff</td>
</tr>

<tr>
<td class="org-left"><code>→'</code></td>
<td class="org-left"><code>¬'φ₁ ∨' φ₂</code></td>
</tr>

<tr>
<td class="org-left"><code>↔'</code></td>
<td class="org-left"><code>(φ₁ →' φ₂) ∧' (φ₂ →' φ₁)</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org0511110" class="outline-3">
<h3 id="org0511110"><span class="section-number-3">7.4</span> <span class="todo TODO">TODO</span> Helper functions</h3>
<div class="outline-text-3" id="text-7-4">
<ul class="org-ul">
<li><code>vars_in list</code></li>
<li><code>vars_in_formula</code></li>
</ul>
</div>
</div>

<div id="outline-container-orga39a46c" class="outline-3">
<h3 id="orga39a46c"><span class="section-number-3">7.5</span> Free and bound variables</h3>
<div class="outline-text-3" id="text-7-5">
<p>
A variable <i>occurs freely</i> in a formula if it present outside of a
quantification, meaning it occurs in the formula somewhere where it is not
immediately preceded by <code>∃'</code> or <code>∀'</code>.
</p>

<p>
We need to be careful with our implementation of this definition because it
contains two distinct ideas. A variable occurs freely in a formula if &#x2013;
</p>
<ol class="org-ol">
<li>It occurs in a formula.</li>
<li><b>Some</b> occurrence in the formula is free.</li>
</ol>

<p>
For example, in the formula \(\phi = \neg'(\forall' v_2 \top) \wedge' (v_1 ='
v_4)\wedge' (\exists v_3 (v_2 =' v_3))\),
</p>
<ul class="org-ul">
<li>the variables \(v_1\) and \(v_4\) occur freely in the formula</li>
<li>the variable \(v_3\) does not occur freely in the formula.</li>
<li>the variable \(v_5\) does not occur freely in the formula (because it does not
occur in the formula at all).</li>
<li>Surprisingly, the variable \(v_2\) occurs freely in the formula.</li>
</ul>
</div>
</div>

<div id="outline-container-orgede1f63" class="outline-3">
<h3 id="orgede1f63"><span class="section-number-3">7.6</span> Definition of a sentence</h3>
<div class="outline-text-3" id="text-7-6">
<p>
A formula in which no variable occurs freely is a sentence.  We create a subtype
of \(L\)-formulas that we call \(L\)-sentences.
</p>

<p>
Every sentence is consequently a formula. The explicit map for this can be
written as
</p>
<div class="org-src-container">
<pre class="src src-lean"><span class="org-keyword">example</span> : setence L <span class="org-constant">&#8594;</span> formula L <span class="org-constant">:=</span> <span class="org-constant">&#955;</span> s, s.val
</pre>
</div>

<p>
We wish to always be able to recover the formula underlying a sentence without
having to specify the above function explicitly. To do this, we declare a
<code>has_coe</code> instance from <code>sentence L</code> to <code>formula L</code>. Thereafter, we can always
reference the underlying formula of a sentence <code>s</code> as <code>↑s</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb25f998" class="outline-2">
<h2 id="orgb25f998"><span class="section-number-2">8</span> Satisfiability and models</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-orgbd425d7" class="outline-3">
<h3 id="orgbd425d7"><span class="section-number-3">8.1</span> <span class="todo TODO">TODO</span> Expanding a language and structure</h3>
</div>
<div id="outline-container-orga69fad5" class="outline-3">
<h3 id="orga69fad5"><span class="section-number-3">8.2</span> Structure models/satisfies a formula</h3>
<div class="outline-text-3" id="text-8-2">
<p>
We now define what it means for a formula to be true in an \(L\)-structure
\(M\), or consequently, what it means for a structure \(M\) to model/satisfy a
formula.
</p>

<p>
Let <code>va : ℕ → M.univ</code> be a given variable assignment.  We denote \(M\)
satisfying the formula \(\phi\) by \(M\models\phi\) and define it inductively as
&#x2013;
</p>
<ul class="org-ul">
<li>\(M\) always satisfies \(\top'\).</li>
<li>\(M\) never satisfies \(\bot'\).</li>
<li>\(M\) satisfies \(t_1 = t_2\) if <code>t₁^^va</code> and <code>t₂^^va</code> match.</li>
<li>\(M\) satisfies \(r\,t_1\ldots t_n\) if the <code>(t₁^^va, ..., tₙ^^va)</code> is in the
set <code>r̂M</code>.</li>
<li>\(M\) satisfies \(\neg \phi\) if it does not satisfy \(\phi\).</li>
<li>\(M\) satisfies \(\phi_1\wedge\phi_2\) if it satisfies both \(phi_1\) and
\(\phi_2\).</li>
<li>\(M\) satisfies \(\phi_1\vee\phi_2\) if it satisfies either \(phi_1\), or
\(\phi_2\), or both.</li>
<li>\(M\) satisfies \(\exists v, \phi\) for some variable \(v\) if there exists
some \(x\) in the domain of \(M\) such that \(M\) satisfies the formula
obtained by replacing all occurrences of \(v\) in \(phi\) by \(x\).</li>
<li>\(M\) satisfies \(\forall v, \phi\) for some variable \(v\) if for every \(x\)
in the domain of \(M\), \(M\) satisfies the formula obtained by replacing all
occurrences of \(v\) in \(phi\) by \(x\).</li>
</ul>
</div>

<div id="outline-container-org3c25bed" class="outline-4">
<h4 id="org3c25bed"><span class="section-number-4">8.2.1</span> Implementation detail for quantifiers</h4>
<div class="outline-text-4" id="text-8-2-1">
<p>
Instead of updating the formula by replacing all occurrences of \(v\) in
\(\phi\) by \(x\), we instead update the variable assignment \(va\) at the point
\(v\) to \(x\).
</p>
</div>
</div>
</div>

<div id="outline-container-orgd45c798" class="outline-3">
<h3 id="orgd45c798"><span class="section-number-3">8.3</span> <span class="todo TODO">TODO</span> Lemmas about satisfaction of formulae</h3>
</div>
<div id="outline-container-orgc88967d" class="outline-3">
<h3 id="orgc88967d"><span class="section-number-3">8.4</span> <span class="todo TODO">TODO</span> Model</h3>
</div>
</div>
<div id="outline-container-orgb82c6fc" class="outline-2">
<h2 id="orgb82c6fc"><span class="section-number-2">9</span> <span class="todo TODO">TODO</span> Bibliography</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Vaibhav Karve</p>
<p class="date">Created: 2021-03-03 Wed 19:37</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
